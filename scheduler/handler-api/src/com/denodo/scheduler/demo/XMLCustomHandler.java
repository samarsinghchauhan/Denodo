/*
 * Copyright (c) 2009. DENODO Technologies.
 * http://www.denodo.com
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of DENODO
 * Technologies ("Confidential Information"). You shall not disclose such
 * Confidential Information and shall use it only in accordance with the terms
 * of the license agreement you entered into with DENODO.
 */
package com.denodo.scheduler.demo;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.denodo.configuration.ConfigurationException;
import com.denodo.configuration.ParameterNotFoundException;
import com.denodo.configuration.ParameterStructure;
import com.denodo.scheduler.api.handler.Handler;
import com.denodo.scheduler.client.job.JobData;
import com.denodo.scheduler.client.job.VDPCacheJobData;
import com.denodo.scheduler.client.job.report.ARNIndexJobReport;
import com.denodo.scheduler.client.job.report.DatabaseJobReport;
import com.denodo.scheduler.client.job.report.JobReport;
import com.denodo.util.exceptions.InternalErrorException;

/**
 * This is a custom handler for Denodo Scheduler. It can take the output generated by a XMLCustomExporter, add job
 * report and job data information to it and transform it into a well-formed XML document. Alternatively, the handler
 * can just generate a XML file containing job report and job data information, taking no XMLCustomExporter input.
 */
public class XMLCustomHandler implements Handler {
    
    /**
     * Logger for this class.
     */
    private static final Logger log = LogManager.getLogger(
        "com.denodo.scheduler.demo.XMLCustomHandler");

    private static final String BLANKS_4 = "    ";
    private static final String BLANKS_8 = BLANKS_4 + BLANKS_4;
    private static final String BLANKS_12 = BLANKS_4 + BLANKS_8;
    private static final String BLANKS_16 = BLANKS_4 + BLANKS_12;
    private static final String BLANKS_20 = BLANKS_4 + BLANKS_16;
    private static final String BLANKS_24 = BLANKS_4 + BLANKS_20;

    /* PathIn: single-valued parameter */
    private static final String PATH_IN_PARAMETER = "Input file absolute path";

    /* PathOut: single-valued parameter */
    private static final String PATH_OUT_PARAMETER = "Output XML file absolute path";

    private String pathIn;
    private String pathOut;
    private boolean noExporterInput;

    /**
     * Implements the handler's activities.
     * <p>
     * The output file is written as the input file is read so this method is memory-efficient.
     */
    @Override
    public void execute(JobData jobData, JobReport jobReport) throws InternalErrorException {

        if (noExporterInput) {
            executeWithNoInput(jobData, jobReport);
        } else {
            executeWithInput(jobData, jobReport);
        }

    }

    /**
     * Implements the handler's activities (when a XMLCustomExporter output file is passed as an input to the handler).
     * <p>
     * The output file is written as the input file is read so this method is memory-efficient.
     * 
     * @param jobData
     *            The JobData instance.
     * @param jobReport
     *            The JobReport instance.
     * @throws InternalErrorException
     */
    private void executeWithInput(JobData jobData, JobReport jobReport) throws InternalErrorException {

        File file = new File(pathOut);
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n".concat("<REPORT>\n")
                .concat(getXMLJobReport(jobReport)).concat(getXMLJobData(jobData)).concat(BLANKS_4)
                .concat("<DOCUMENTS>\n");

        pathOut = file.getPath();
        if (pathOut.contains(File.separator)) {
            File dirs = new File(pathOut.substring(0, pathOut.lastIndexOf(File.separator)));
            dirs.mkdirs();
        }
        File file2 = new File(pathIn);
        pathIn = file2.getPath();
        if (pathIn.compareTo(pathOut) == 0) {
            file = new File(pathOut + ".tmp");
        }

        try (FileOutputStream fop = new FileOutputStream(file);
                BufferedReader in = new BufferedReader(new FileReader(pathIn));) {

            if (file.exists()) {

                fop.write(xml.getBytes());
                fop.flush();

                String line;

                while ((line = in.readLine()) != null) {
                    fop.write(addBlanks(line.concat("\n"), BLANKS_8).getBytes());
                    fop.flush();
                }

                fop.write((BLANKS_4.concat("</DOCUMENTS>\n</REPORT>\n")).getBytes());
                fop.flush();

                if (pathIn.compareTo(pathOut) == 0) {
                    File inFile = new File(pathIn);
                    in.close();
                    if (inFile.delete()) {
                        fop.close();
                        if (!file.renameTo(new File(pathOut))) {
                            log.error("Error renaming file: " + file);
                        }
                    }
                }
            }

        } catch (IOException e) {
            throw new InternalErrorException(e);
        }
    }

    /**
     * Implements the handler's activities (when no input file is passed to the handler).
     * 
     * @param jobData
     *            The JobData instance.
     * @param jobReport
     *            The JobReport instance.
     * @throws InternalErrorException
     */
    private void executeWithNoInput(JobData jobData, JobReport jobReport) throws InternalErrorException {

        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n".concat("<REPORT>\n")
                .concat(getXMLJobReport(jobReport)).concat(getXMLJobData(jobData)).concat("</REPORT>\n");

        File file = new File(pathOut);
        pathOut = file.getPath();
        if (pathOut.contains(File.separator)) {
            File dirs = new File(pathOut.substring(0, pathOut.lastIndexOf(File.separator)));
            dirs.mkdirs();
        }

        try (FileOutputStream fop = new FileOutputStream(file);) {

            if (file.exists()) {
                fop.write(xml.getBytes());
                fop.flush();
            }

        } catch (IOException e) {
            throw new InternalErrorException(e);
        }
    }

    /**
     * Transforms a JobReport instance into a XML string.
     * 
     * @param jobReport
     *            The JobReport
     * @return The XML string for the passed jobReport instance
     */
    private String getXMLJobReport(JobReport jobReport) {

        String jobReportXML = BLANKS_4.concat("<JOB_REPORT>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<FIRST_TIME>")
                .concat(String.valueOf(jobReport.getFirstTime())).concat("</FIRST_TIME>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<ID>").concat(String.valueOf(jobReport.getId()))
                .concat("</ID>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<JOB_ID>").concat(String.valueOf(jobReport.getJobID()))
                .concat("</JOB_ID>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<JOB_NAME>").concat(jobReport.getJobName())
                .concat("</JOB_NAME>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<JOB_TYPE>").concat(jobReport.getJobType())
                .concat("</JOB_TYPE>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<RETRY_COUNT>")
                .concat(String.valueOf(jobReport.getRetryCount())).concat("</RETRY_COUNT>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<END_TIME>").concat(String.valueOf(jobReport.getEndTime()))
                .concat("</END_TIME>\n");
        if (!jobReport.getInitializationErrors().isEmpty()) {
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<INITIALIZATION_ERRORS>\n");
            for (Object error : jobReport.getInitializationErrors()) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<ERROR>").concat(error.toString())
                        .concat("</ERROR>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</INITIALIZATION_ERRORS>\n");
        }
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<RETRY_JOB>")
                .concat(String.valueOf(jobReport.getRetryJob())).concat("</RETRY_JOB>\n");
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<START_TIME>")
                .concat(String.valueOf(jobReport.getStartTime())).concat("</START_TIME>\n");
        jobReportXML = jobReportXML.concat(visite(jobReport));
        jobReportXML = jobReportXML.concat(BLANKS_4).concat("</JOB_REPORT>\n");

        return jobReportXML;
    }

    /**
     * Depending on the class of the JobReport instance passed as a parameter, this method returns the specific
     * information contained in it as a XML String.
     * 
     * @param jobReport
     *            A JobReport instance
     * @return The XML String
     */
    private String visite(JobReport jobReport) {

        if (jobReport instanceof DatabaseJobReport) {
            return visite((DatabaseJobReport) jobReport);
        } else if (jobReport instanceof ARNIndexJobReport) {
            return visite((ARNIndexJobReport) jobReport);
        } else {
            return "";
        }
    }

    /**
     * Converts the DatabaseJobReport specific information of the passed report to a XML String.
     * 
     * @param jobReport
     *            A DatabaseJobReport instance
     * @return The XML String
     */
    private String visite(DatabaseJobReport jobReport) {

        String jobReportXML = "";
        if (jobReport.getQuery() != null) {
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<QUERY>").concat("<![CDATA[")
                    .concat(jobReport.getQuery()).concat("]]>").concat("</QUERY>\n");
        }
        jobReportXML = jobReportXML.concat(BLANKS_8).concat("<EXTRACTED_DOCS>")
                .concat(String.valueOf(jobReport.getExtractedDocs())).concat("</EXTRACTED_DOCS>\n");
        Collection<Object> initializationErrors = jobReport.getInitializationErrors();
        if (CollectionUtils.isNotEmpty(initializationErrors)) {
            Object[] errors = initializationErrors.toArray();
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<INITIALIZATION_ERRORS>\n");
            for (Object error : errors) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<ERROR>").concat((String) error)
                        .concat("</ERROR>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</INITIALIZATION_ERRORS>\n");
        }
        Map<String, Long> exportedDocs = jobReport.getExportedDocs();
        if (MapUtils.isNotEmpty(exportedDocs)) {
            Set<Entry<String, Long>> docsEntries = exportedDocs.entrySet();
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<EXPORTED_DOCS>\n");
            for (Entry<String, Long> docEntry : docsEntries) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<EXPORTATION>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<PROCESSOR>").concat(docEntry.getKey())
                        .concat("</PROCESSOR>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<EXTRACTED_TUPLES>")
                        .concat(docEntry.getValue().toString()).concat("</EXTRACTED_TUPLES>\n");
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("</EXPORTATION>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</EXPORTED_DOCS>\n");
        }
        Collection<Object> extractorErrors = jobReport.getExtractorErrors();
        if (CollectionUtils.isNotEmpty(extractorErrors)) {
            Object[] errors = extractorErrors.toArray();
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<EXTRACTOR_ERRORS>\n");
            for (Object error : errors) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<ERROR>\n").concat((String) error)
                        .concat("</ERROR>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</EXTRACTOR_ERRORS>\n");
        }
        Map<String, Collection<String>> exporterErrors = jobReport.getExporterErrors();
        if (MapUtils.isNotEmpty(exporterErrors)) {
            Set<Entry<String, Collection<String>>> docsEntries = exporterErrors.entrySet();
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<EXPORTER_ERRORS>\n");
            for (Entry<String, Collection<String>> docEntry : docsEntries) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<EXPORTER_ERRORS_ENTRY>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<EXPORTER>\n").concat(docEntry.getKey())
                        .concat("</EXPORTER>\n");
                Collection<String> errors = docEntry.getValue();
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<ERRORS>\n");
                for (String error : errors) {
                    jobReportXML = jobReportXML.concat(BLANKS_20).concat("<ERROR>\n").concat(error)
                            .concat("</ERROR>\n");
                }
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("</ERRORS>\n");
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("</EXPORTER_ERRORS_ENTRY>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</EXPORTER_ERRORS>\n");
        }
        List<Integer> failedExecutions = jobReport.getFailedExecutions();
        if (CollectionUtils.isNotEmpty(failedExecutions)) {
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<FAILED_EXECUTIONS>\n");
            Integer[] failArr = failedExecutions.toArray(new Integer[failedExecutions.size()]);
            for (Integer fail : failArr) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<FAILED_EXECUTION>\n").concat(fail.toString())
                        .concat("</FAILED_EXECUTION>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</FAILED_EXECUTIONS>\n");
        }
        Map<Integer, DatabaseJobReport> individualReports = jobReport.getReports();
        if (MapUtils.isNotEmpty(individualReports)) {
            Set<Entry<Integer, DatabaseJobReport>> entries = individualReports.entrySet();
            for (Entry<Integer, DatabaseJobReport> entry : entries) {
                jobReportXML = jobReportXML.concat(BLANKS_8).concat("<INDIVIDUAL_REPORT>\n");
                jobReportXML = jobReportXML.concat(addBlanks(visite(entry.getValue()), BLANKS_8));
                jobReportXML = jobReportXML.concat(BLANKS_8).concat("</INDIVIDUAL_REPORT>\n");
            }
        }

        return jobReportXML;
    }

    /**
     * Converts the ARNIndexJobReport specific information of the passed report to a XML String.
     * 
     * @param jobReport
     *            An ARNIndexJobReport instance
     * @return The XML String
     */
    private static String visite(ARNIndexJobReport jobReport) {

        String jobReportXML = "";

        Map<String, String> maintenanceErrors = jobReport.getMaintenanceErrors();
        if (MapUtils.isNotEmpty(maintenanceErrors)) {
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<MAINTENANCE_ERRORS>\n");
            Set<Entry<String, String>> maintenanceErrorsEntries = maintenanceErrors.entrySet();
            for (Entry<String, String> maintenanceErrorsEntry : maintenanceErrorsEntries) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<MAINTENANCE_ERROR>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<ID>").concat(maintenanceErrorsEntry.getKey())
                        .concat("</ID>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<DESCRIPTION>")
                        .concat(maintenanceErrorsEntry.getValue()).concat("</DESCRIPTION>\n");
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("</MAINTENANCE_ERROR>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</MAINTENANCE_ERRORS>\n");
        }
        Map<String, Map> maintenanceResults = jobReport.getMaintenanceResults();
        if (MapUtils.isNotEmpty(maintenanceResults)) {
            Set<Entry<String, Map>> maintenanceResultsEntries = maintenanceResults.entrySet();
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("<MAINTENANCE_RESULTS>\n");
            for (Entry<String, Map> maintenanceResultsEntry : maintenanceResultsEntries) {
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("<MAINTENANCE_RESULT>\n");
                jobReportXML = jobReportXML.concat(BLANKS_16).concat("<ID>").concat(maintenanceResultsEntry.getKey())
                        .concat("</ID>\n");
                for (Entry entry : (Set<Entry>) maintenanceResultsEntry.getValue().entrySet()) {
                    if (entry.getValue() instanceof Map) {
                        if (!((Map) entry.getValue()).entrySet().isEmpty()) {
                            jobReportXML = jobReportXML.concat(BLANKS_16).concat("<RESULT>\n");
                            for (Entry e : (Set<Entry>) ((Map) entry.getValue()).entrySet()) {
                                jobReportXML = jobReportXML.concat(BLANKS_20).concat("<ITEM>\n");
                                jobReportXML = jobReportXML.concat(BLANKS_24).concat("<KEY>")
                                        .concat(e.getKey().toString()).concat("</KEY>\n");
                                jobReportXML = jobReportXML.concat(BLANKS_24).concat("<VALUE>")
                                        .concat(e.getValue().toString()).concat("</VALUE>\n");
                                jobReportXML = jobReportXML.concat(BLANKS_20).concat("</ITEM>\n");
                            }
                            jobReportXML = jobReportXML.concat(BLANKS_16).concat("</RESULT>\n");
                        }
                    } else {
                        jobReportXML = jobReportXML.concat(BLANKS_16).concat("<RESULT>\n");
                        jobReportXML = jobReportXML.concat(BLANKS_20).concat("<INDEX>")
                                .concat(entry.getKey().toString()).concat("</INDEX>\n");
                        jobReportXML = jobReportXML.concat(BLANKS_20).concat("<DELETED_DOCUMENTS>")
                                .concat(entry.getValue().toString()).concat("</DELETED_DOCUMENTS>\n");
                        jobReportXML = jobReportXML.concat(BLANKS_16).concat("</RESULT>\n");
                    }
                }
                jobReportXML = jobReportXML.concat(BLANKS_12).concat("</MAINTENANCE_RESULT>\n");
            }
            jobReportXML = jobReportXML.concat(BLANKS_8).concat("</MAINTENANCE_RESULTS>\n");
        }

        return jobReportXML;
    }

    /**
     * Transforms a JobData instance into a XML string.
     * 
     * @param jobData
     *            The JobData
     * @return The XML string for the passed JobData instance
     */
    private static String getXMLJobData(JobData jobData) {

        String jobDataXML = BLANKS_4.concat("<JOB_DATA>\n");
        if (jobData.getName() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<JOB_NAME>").concat(jobData.getName())
                    .concat("</JOB_NAME>\n");
        }
        if (jobData.getProjectName() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<PROJECT_NAME>").concat(jobData.getProjectName())
                    .concat("</PROJECT_NAME>\n");
        }
        if (jobData.getType() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<JOB_TYPE>").concat(jobData.getType())
                    .concat("</JOB_TYPE>\n");
        }
        Map exportationResult = jobData.getExportationResult();
        if (MapUtils.isNotEmpty(exportationResult)) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<EXPORTATION_RESULT>\n");
            for (String key : (Set<String>) exportationResult.keySet()) {
                jobDataXML = jobDataXML.concat(BLANKS_12).concat("<EXPORTATION>\n").concat(BLANKS_16)
                        .concat("<PROCESSOR>").concat(key).concat("</PROCESSOR>\n").concat(BLANKS_16)
                        .concat("<EXTRACTED_TUPLES>").concat(exportationResult.get(key).toString())
                        .concat("</EXTRACTED_TUPLES>\n").concat(BLANKS_12).concat("</EXPORTATION>\n");

            }
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("</EXPORTATION_RESULT>\n");
        }
        jobDataXML = jobDataXML.concat(BLANKS_8).concat("<EXTRACTION_RESULT>")
                .concat(String.valueOf(jobData.getExtractionResult())).concat("</EXTRACTION_RESULT>\n");
        jobDataXML = jobDataXML.concat(BLANKS_8).concat("<FIRST_EXECUTION>")
                .concat(String.valueOf(jobData.getFirstExecution())).concat("</FIRST_EXECUTION>\n");
        jobDataXML = jobDataXML.concat(BLANKS_8).concat("<JOB_ID>").concat(String.valueOf(jobData.getJobID()))
                .concat("</JOB_ID>\n");
        if (jobData.getLastResult() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<LAST_RESULT>").concat(jobData.getLastResult().name())
                    .concat("</LAST_RESULT>\n");
        }
        if (jobData.getNextExecution() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<NEXT_EXECUTION>")
                    .concat(jobData.getNextExecution().toString()).concat("</NEXT_EXECUTION>\n");
        }
        if (jobData.getPreviousExecution() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<PREVIOUS_EXECUTION>")
                    .concat(jobData.getPreviousExecution().toString()).concat("</PREVIOUS_EXECUTION>\n");
        }
        jobDataXML = jobDataXML.concat(BLANKS_8).concat("<PROJECT_ID>").concat(String.valueOf(jobData.getProjectId()))
                .concat("</PROJECT_ID>\n");
        if (!(jobData instanceof VDPCacheJobData)) {
            List<Integer> queryErrors = (List<Integer>) jobData.getQueryErrors();
            if (CollectionUtils.isNotEmpty(queryErrors)) {
                jobDataXML = jobDataXML.concat(BLANKS_8).concat("<QUERY_ERRORS>\n");
                Integer[] errorsArr = queryErrors.toArray(new Integer[queryErrors.size()]);
                for (Integer error : errorsArr) {
                    jobDataXML = jobDataXML.concat(BLANKS_12).concat("<ERROR>").concat(error.toString())
                            .concat("</ERROR>\n");
                }
                jobDataXML = jobDataXML.concat(BLANKS_8).concat("</QUERY_ERRORS>\n");
            }
        }
        jobDataXML = jobDataXML.concat(BLANKS_8).concat("<RETRY_COUNT>").concat(String.valueOf(jobData.getRetryCount()))
                .concat("</RETRY_COUNT>\n");
        if (jobData.getState() != null) {
            jobDataXML = jobDataXML.concat(BLANKS_8).concat("<STATE>").concat(jobData.getState().name())
                    .concat("</STATE>\n");
        }
        jobDataXML = jobDataXML.concat(BLANKS_4).concat("</JOB_DATA>\n");

        return jobDataXML;
    }

    /**
     * Indents a XML string with the passed blank string.
     * 
     * @param xml
     *            The XML String.
     * @param blanks
     *            The blank string.
     * @return The indented XML String.
     */
    private static String addBlanks(String xml, String blanks) {

        String out = "";

        String[] lines = xml.split("\n");
        for (String line : lines) {
            out = out.concat(blanks).concat(line).concat("\n");
        }

        return out;
    }

    /**
     * Initialize method. The following configuration parameters are supported:
     * <ul>
     * <li>PATH_IN_PARAMETER: the absolute path to the desired input file (optional)
     * <li>PATH_OUT_PARAMETER: the absolute path to the desired XML output file (required)
     * </ul>
     * 
     * @param params
     *            the parameters
     */
    @Override
    public void init(ParameterStructure params) throws ConfigurationException {

        String pathInParameter = "";
        String pathOutParameter;

        try {
            pathInParameter = (String) params.get(PATH_IN_PARAMETER).getValue();
        } catch (ParameterNotFoundException e) {
            noExporterInput = true;
        }
        try {
            pathOutParameter = (String) params.get(PATH_OUT_PARAMETER).getValue();
        } catch (ParameterNotFoundException e) {
            throw new ConfigurationException("Output path parameter not found");
        }

        pathIn = pathInParameter;
        pathOut = pathOutParameter;
    }

}
